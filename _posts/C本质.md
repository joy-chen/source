---
title: C本质
date: 2018-01-17 15:01:56
tags:
---

Author JOY.
<!-- excerpt -->

## 关键字
### static
对于局部变量来说：将其放在 data 段，即初始化一次，且限定作用域为定义的函数或语句块。   
对于全局变量和函数来说：限定其作用域在本文件中

### const
对于全局变量来说：将变量放在rodata段，由MMU通过页表项的权限位保证其只读属性
对于局部变量来说：变量依然放在栈里，由编译器保证其只读属性
const 修饰数组，数组每个元素的值都不能改变

### sizeof
sizeof是关键字
sizeof接具体数字时可不加括号，接类型时一定要加括号

### volatile
两个基本作用：   
1.禁止编译其优化其修饰代码   
2.用在汇编，asm volatile, 禁止编译器对代码的优化（顺序及删减）

### 关于地址
物理地址:外设(内存)在总线上的实际地址    
虚拟地址:开启 MMU 之后，程序中指令或数据的地址。虚拟地址最终被 MMU 映射到内存在总线上的物理地址  
绝对地址:程序运行时指令或数据的地址    
相对地址:相对与PC的地址
链接地址:由链接器确定的load到内存的地址

### 指针和引用的区别
* 指针可以为 NULL，引用不能为空值
* 引用的值不可改变，而指针的值可以改变

## C基础

1.从 x = y 所看到的：这只是一组 load store 指令
ex:ldr r0, [fp, #-8] ldr y 的值 str r0, [fp, #-12] str 到 x 的地址   
编译器为每个变量分配地址，每个符号的地址在编译时已经确定（即 load 地址）的，如果编译器需要一个地址（可能加上偏移量）来操作，他可以直接操作，并不需要增加指令首先获取具体的地址   

2.char *p = “abcdef”; 与 char p[] = “abcdef”;的区别   
首先：“abcdef”是存放再 rodata 段的 char *p = “abcdef”; 只为指针 p 开辟一个空间，指向 rodata 段的字符串，不可以修改 char p[] = “abcdef”;用时将字符串拷贝到栈里（如果局部）即开辟空间，可以修改；   

3.syscall 的过程（以 arm 平台，mount 函数为例）：
mount（） {
  swi #n
}
此条指令有 sub lr， pc， #4； mov pc，#0x08 的动作  
切换到内核模式（swi 异常模式），pc 指向对应的异常入口地址并跳转执行， 0x08： b handle_swi;
handle_swi: stmfd sp!, {r0-r12, lr} b swi_handle ldmfd sp!, {r0-r12, pc}
swi_handle(int n) {
  (syscall[n])();
}
此时可以根据 ldr r0，[lr, #-4] bic r0, r0, 0xff000000 得到系统调用号 n。

4.进程和线程：   
进程是资源的基本单位，线程是调度的基本单位
